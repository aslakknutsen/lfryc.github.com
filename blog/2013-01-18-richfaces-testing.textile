---
layout: post
title: "Arquillian: Revolutionary Testing Platform (not only) for JSF"
tags: [ "arquillian", "warp", "graphene", "richfaces" ]
---

As we announced earlier, we are undergoing several changes in how RichFaces is tested. We already have an extensive functional test suite authored by a top-notch RichFaces QE team (honestly, I like this band of engineers), but what *this suite doesn't allow us is reacting quickly on regressions* we introduced and then we usually find some of them during a release testing.

We came to conclusion that we are doing *real testing too late after a commit*. Certainly, we do lot of unit-testing and we write many integration tests - however they didn't guard us from real bugs. They cover just a small part of a logic which is finally executed between the client and the server.

h3. The Integration Environment Complexity

The problem which we face here is given by a complexity of the client-server nature of web frameworks like JSF. The testing is so complex that it is often avoided while underestimating the importance of testing client-server interaction.

In RichFaces, we build on top of client-side libraries like jQuery and jQuery UI and we let them communicate through jsf.js library with the JSF backend on the application server.

h4. Unit Testing

You can certainly unit-test JavaScript code and you can write unit tests for utilities handling with JSF. This will ensure that units works in separation.

h4. Component Testing with Mocks

But the units we need to test are JSF components which are composed from a client-side code, XML templates and a Java code and a configuration. Moreover in Java EE (and JSF in particular) each object talks with many other objects and.

So that's a point when it usually comes to integration testing (also called  component testing). Someone may think that this is kind of interaction which can be tested by mocks.

But at the end we have end up with many mocks and we got nothing else than extra work for compiler and huge amount of code to maintain.

Using mocks for component or integration testing is no way to success.

h4. Mock Environment

In order to avoid duplicating of the setup of mocks, we have built whole mock-environment called @jsf-test@. In this environment, you can leverage pre-configured mocks for standard JSF objects.

This framework also brings mock servlet container which starts in miliseconds. @jsf-test@ also leverages HtmlUnit as mock browser to allow high-level web testing. HtmlUnit communicates with mock servlet container through message passing which avoids HTTP communication overhead. So as you might expect, it is damn fast. :-)

It may work just fine for JSF-only testing, but it simply becomes overwhelming to prepare such mock-environment for whole Java EE stack.

However the biggest pain of @jsf-test@ is that it isn't enough real - it does not ensure things work right in real deployments - in real applications servers and real browsers.

div(alert alert-info). HtmlUnit is just artifical headless implementation of a web browser. This fact is even more perceivable when trying to debug tests written in HtmlUnit.

h4. NoMock - Testing utopia?

So as you can see, integration nowadays isn't about writing tests, but it is rather about setting up test-harness which will help your team to ramp up quickly. It is not much fun and you will need to duplicate the effort each time you start with a new project.

That's why you have may seen so many people telling that mocking is not way forward either.

h3. Arquillian for the Rescue

Fortunately, there is one team, which lives with the idea of "NoMocking at all" in mind.

The Arquillian is revolutionary testing platform which focuses on simple idea: don't bring test to a server, bring a server to the test.

It builds on top of inversion control principle and let you inject the pieces of real application server to your test, where you can test them either by calling server-side APIs or observing events.

h4. Effortless Test Harness

Arquillian integrates with every application container out there in unified manner, so it's very easy to set it up for cross-container testing.

It also have many and many extensions for testing specific problems from Java EE world or outside.

h4. Get Me Real Browser

For RichFaces, it is most important that it allow you to leverage real browser testing using the Drone extension. Drone basically brings the browser to the test and exposes it to you using widely-adopted WebDriver API.

div(alert alert-info). Note: WebDriver is Selenium 2 API, which is being in process of W3C standardation as Browser Automation

No matter which browser you use, you will write the same test just once and you will be empowered to run it on (almost) every browser out there in unified manner.

div(alert alert-warning). Warning: in reality, you will perceive some incompatibilities in browser implementations, but you can work around them by using right tools

That way, you can run your tests everywhere:

* on many versions of all desktop browsers
* on lot of mobile devices
* on mocked browsers (yeah, the same we have spurned before)
* remotely on virtualized browser grids (on-demand)
* remotely using the cloud browser provider

h4. Arquillian Saves the Day

Using the WebDriver API you can let browser of your choice to talk to the application server of your choice.

That's nice, we can test real implementation and we got the test harness really for free.

But we can do much more.

h3. Gray-Box Testing

h4. Warp your test from Client to Server

But what we haven't got a way how really test the what's happening when we trigger client-side code (e.g. hit a button) on the server-side (e.g. CDI events is raised).

That's exactly where Arquillian's Warp extension comes in - it allows you to write tests as combination of client-side activities and inspect what's happening in server:

bc(prettify).. Warp
    .initiate(Activity)
    .inspect(Inspection);

p. It will basically do anything you can do on client-side and once your client makes a HTTP request to the server, you can inspect whatever happens in server-side (using familiar Arquillian APIs).

In the words of JSF, you can manipulate with JSF components on the page and you can inspect what happened during JSF lifecycle with their state, with the state of the beans or even what messages were produced as the response to user's action.

h3. Testing AJAX-heavy applications

You could be all setup now, but you will quickly get to the conclusion that WebDriver itself isn't strong to deal with highly-interactive applications - either client-side or AJAXified (as in case of RichFaces).

That's why we have started another subproject of Arquillian: the Graphene.

Graphene allows you to precisely explain what's happening on the client-side so the test will execute exactly and deterministically: once you do some interactive action (e.g. clicking on button or typing text), you need to wait before the browser responds appropriately - this might be in the resolution of miliseconds when doing just styling update, but it might become hundreds of miliseconds in case of complex GUI operations or even several seconds when communicating with server.

And Graphene gives you ability to describe it with fluent API:

bc(prettify).. addButton.click();
waitGui().until().element(newRecord).is().present();

assertEquals(..., newRecord.getText());

p. Ironically, it's even simpler to wait for communication, since Graphene allows you to intercept the communication and block until it ends:

bc(prettify).. guardXhr(searchButton).click();
assertEquals(..., searchResults.get(0).getText();

p. But this is  not really the style how the tests should be written - no one wants to decode what test does in order to even understand its purpose.

h3. Page Abstractions

That's why we have adopted Page Objects pattern which tells you to abstract the complexity to reusable pieces.

Just we took it little bit further and in Graphene, you can define so called Page Fragments, which will allow you to abstract small pieces of the pages which are used repeatedly and allow perfect re-use through whole project. In the world of JSF, those pieces might be JSF components. Then you can bring those page fragments right into your page:

bc(prettify).. @FindBy(id = "form:birthDate")
RichfacesCalendar birthDate;

@Test
public void test() {
  ...
  birthDate.setDate(xyz);
  ...
}

p. That was not hard, was it?

The same way you abstract your server-side business logic, you can abstract your definitions on the page.

Note: we intend to abstract all RichFaces components so you could reuse them in your projects

h2. Integration Testing First Principle

But whatever tool we are using, we still run on real stuff and that's slow, right? Not exactly.

h3. Fast Turnaround

With the right tools employed, you can achieve really fast turnaround.

Even though containers nowadays starts blazingly fast (4 seconds for containers like JBoss AS or TomEE), you should use manually started  container and let Arquillian connect to it with remote container adapter.

When constructing application deployment, you should use as minimal deployment as possible - it will take less time to create it, but more importantly it will be started faster on container.

And the same as you have used remote server, you can start Selenium server remotely and let Drone connect to it remotely and reuse the browser session instantiated in previous run.

This way we was able to achieve turnaround 4 seconds for simple UI tests and e.g. 8 seconds for more complex ones. It could be improved further, but certainly that's not enough to get you distracted from test to favorite social network. ;-)

Note: In case that you have deployment which takes longer time to deploy, you can leverage JRebel extension, which basically caches deployment and once the test is ran again, it will hot-deploy changes

h3. Verify code preciselly

Once the test suite is written, you need to run it continuously to ensure that your application is compatible across all supported browsers (and containers). That's pretty simple task with Arquillian (arquillian.xml configuration) and Maven (pom.xml profiles configuration).

I won't dive into this configuration now.

I would rather highlight, that since you are running tests in continuous integration, you should leverage Arquillian managed containers to bootstrap your container - Arquillian will make sure to start container before test suite, etc.

The Drone extension, on the other hand, allows to instiate browsers directly, without need of running instance of Selenium Server.

h3. Leverage browsers in the cloud

Another option is use cloud browser providers like SauceLabs, which avoids necessity to host the real browsers in your company and thus decreases the infrastructure and setup investments.

h3. Unit test, baby!

You may opt that this still does not give you real continuous integration benefits like fast feedback.

And that's where Drone shines again: you may simply switch from real browser to mocked browser.

That way Arquillian will automatically start up container, Drone will start mocked browser and the tests will be executed without need of any prepared enviroment and faster than in real browsers.

Just note, that you can get really precise results, near to real browser implementation, when you use right mocked browser implementation like PhantomJS, which is near to Chrome implementation.

h2. Let developers and QE get along

What we did prepared as also for paradigm switch: our QE does not ensure all testing of UI, but they are responsible for verifying UI by tests which are already written.

Note that this does not completely eliminate manual testing, it will be always necessary, but at least it minimizes it to appropriate level.

h3. Developers Responsible for Testing

The responsibility for writing initial tests for every new component was laid on developers.

The reason of this is simple: the developer can write test to support his development and get more confidence in the changes he or his colleagues made.

He can run tests before commit and then pass them to continuous integration so the commits will be double-checked and developer will get fast feedback if they don't pass.

h3. QE run tests in real environment and improves them

Without responsibility of writing tests, QE can focus on extending the coverage by porting tests to supported platforms and thus increase confidence in code of the application.

Additionally, then can change and extend tests as necessary, since they are not so hard to read and write using Page Fragments.

h2. Conclusion

As a result, we can now:

* develop test fast
* test what is important
* test with real browsers (optionally: in the cloud)
* test with real container
* run integration tests as they would be unit tests

We have put pretty extensive effort to improve testing, because we believe its fundamental part of success of every open-source project where many people may contribute to.

And what's even better that you can achieve the same success because we are development those tools in open!

h2. Call to Action

Call to all responsible developers and managers: There is no longer any excuse for not testing your code!

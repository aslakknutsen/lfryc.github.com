---
layout: post
title: "Arquillian: Revolutionary Testing Platform (not only) for JSF"
tags: [ "arquillian", "warp", "graphene", "richfaces" ]
---

As we announced earlier, we were undergoing several changes in how RichFaces is tested. We already have extensive functional test suite authored by top-notch RichFaces QE team (honestly, I like this band of engineers), but what it doesn't allow us is react quickly on regressions we introduced and we usually find some of them during release testing.

We came to conclusion that we are doing real testing too far from the code. No, certainly, we unit-test, we write integration tests - but those does not guard you from real bugs! They cover just small part of the logic which is finally executed between client and the server.

h3. The Integration Environment Complexity

The problem which we face here is given by complexity of client-server nature of web frameworks like JSF. It is so complex that people too often just overlook it - too bad that they are actually underestimating the importance of testing this interaction.

In RichFaces, we build on top of client-side libraries like jQuery and jQuery UI and we let them communicate through jsf.js library to JSF backend on the application server.

h5. Unit Testing

You can certainly unit test JavaScript side and you can write unit tests for utilities handling with JSF. This will ensure that the simplest pieces works alone.

h5. Mocking

When it comes to integration testing, in Java EE, and JSF in particular, each object talks with many other objects and you need to mock all of them. So you can end up with many mocks and you will get nothing else than extra work for compiler. On the other hand you will get more and more code to maintain.

h5. Integration Mocking

So you can take mocking further, take a JSF (or any other Java EE component) and bootstrap it separately and mock everything else around  to get working container. Then you can take mocked browser and let it communicate to container. And the result will be working integration test.

It can work for JSF-focused development, but it will simply get overwhelming and maintanance burden to set this up for full Java EE stack. At the end, you will probably get a fork of application server, running no faster.

But the real problem comes with using mocked browser - when you don't run on real browser, you can't be sure your implementation is actually working in real environment, right?

h5. Don't mock me - testing utopia?

So as you can see, integration nowadays isn't about writing tests, but its about setting up test-harness which will help your team to ramp up quickly. And its really not fun. And you need to do it with every project you start with.

It's especially hard when it comes to test with real environment - and what we developers usually do here: we don't test, it's not our priority.

!!!!!!!!!!!

The Arquillian is revolutionary testing platform which focuses on simple idea: don't bring test to a server, bring a server to the test.

It builds on top of inversion control principle and let you inject the pieces of real application server to your test, where you can communicate with them - either call server-side APIs or observe events.

h2. Test Harness

Arquillian integrates with every application container out there in unified manner, so it's very easy to set it up for cross-container testing.

It also have many and many extensions for testing specific problems.

For RichFaces, it is most important that it allow you to leverage real browser testing using the Drone extension. Drone basically brings the browser to the test and exposes it to you using widely-adopted WebDriver API.

Note: WebDriver is Selenium 2 API, which is being in process of W3C standardation as Browser Automation

The important is, that from Drone, you can hear faimilar story: no matter which browser you use, you will write the same test once, you will get the WebDriver injected to the test and it will run on every available browser out there.

Warning: this is over-simplified, you will get issues, but you can overcome them

And if I say everywhere, I mean everywhere:

* on every fucking version of desktop browser
* on lot of mobile devices
* on mocked browsers (yeah, the same we have spurned before)
* remotely using the browser-grid software
* remotely using the cloud browser provider

Using the WebDriver API you can let browser of your choice to talk to the application server of your choice.

That's nice, we can test real implementation and we got the test harness really for free.

h2. Gray-Box Testing: Warp your test from Client to Server

But what we haven't got a way how really test the what's happening when we trigger client-side code (e.g. hit a button) on the server-side (e.g. CDI events is raised).

That's exactly where Arquillian's Warp extension comes in - it allows you to write tests as combination of client-side activities and inspect what's happening in server:

bc(prettify).. Warp
    .initiate(Activity)
    .inspect(Inspection);

p. It will basically do anything you can do on client-side and once your client makes a HTTP request to the server, you can inspect whatever happens in server-side (using familiar Arquillian APIs).

In the words of JSF, you can manipulate with JSF components on the page and you can inspect what happened during JSF lifecycle with their state, with the state of the beans or even what messages were produced as the response to user's action.

h2. Testing AJAX-heavy applications

You could be all setup now, but you will quickly get to the conclusion that WebDriver itself isn't strong to deal with highly-interactive applications - either client-side or AJAXified (as in case of RichFaces).

That's why we have started another subproject of Arquillian: the Graphene.

Graphene allows you to precisely explain what's happening on the client-side so the test will execute exactly and deterministically: once you do some interactive action (e.g. clicking on button or typing text), you need to wait before the browser responds appropriately - this might be in the resolution of miliseconds when doing just styling update, but it might become hundreds of miliseconds in case of complex GUI operations or even several seconds when communicating with server.

And Graphene gives you ability to describe it with fluent API:

bc(prettify).. addButton.click();
waitGui().until().element(newRecord).is().present();

assertEquals(..., newRecord.getText());

p. Ironically, it's even simpler to wait for communication, since Graphene allows you to intercept the communication and block until it ends:

bc(prettify).. guardXhr(searchButton).click();
assertEquals(..., searchResults.get(0).getText();

p. But this is  not really the style how the tests should be written - no one wants to decode what test does in order to even understand it's purpose:

That's why we have adopted Page Objects pattern which tells you to abstract the complexity to reusable pieces.

Just we took it little bit further and in Graphene, you can define so called Page Fragments, which will allow you to abstract small pieces of the pages which are used repeatedly and allow perfect re-use through whole project. In the world of JSF, those pieces might be JSF components. Then you can bring those page fragments right into your page:

bc(prettify).. @FindBy(id = "form:birthDate")
RichfacesCalendar birthDate;

@Test
public void test() {
  ...
  birthDate.setDate(xyz);
  ...
}

p. That was not hard, was it?

The same way you abstract your server-side business logic, you can abstract your definitions on the page.

Note: we intend to abstract all RichFaces components so you could reuse them in your projects

h2. Integration Testing First Principle

But whatever tool we are using, we still run on real stuff and that's slow, right? Not exactly.

h3. Fast Turnaround

With the right tools employed, you can achieve really fast turnaround.

Even though containers nowadays starts blazingly fast (4 seconds for containers like JBoss AS or TomEE), you should use manually started  container and let Arquillian connect to it with remote container adapter.

When constructing application deployment, you should use as minimal deployment as possible - it will take less time to create it, but more importantly it will be started faster on container.

And the same as you have used remote server, you can start Selenium server remotely and let Drone connect to it remotely and reuse the browser session instantiated in previous run.

This way we was able to achieve turnaround 4 seconds for simple UI tests and e.g. 8 seconds for more complex ones. It could be improved further, but certainly that's not enough to get you distracted from test to favorite social network. ;-)

Note: In case that you have deployment which takes longer time to deploy, you can leverage JRebel extension, which basically caches deployment and once the test is ran again, it will hot-deploy changes

h3. Verify code preciselly

Once the test suite is written, you need to run it continuously to ensure that your application is compatible across all supported browsers (and containers). That's pretty simple task with Arquillian (arquillian.xml configuration) and Maven (pom.xml profiles configuration).

I won't dive into this configuration now.

I would rather highlight, that since you are running tests in continuous integration, you should leverage Arquillian managed containers to bootstrap your container - Arquillian will make sure to start container before test suite, etc.

The Drone extension, on the other hand, allows to instiate browsers directly, without need of running instance of Selenium Server.

h3. Leverage browsers in the cloud

Another option is use cloud browser providers like SauceLabs, which avoids necessity to host the real browsers in your company and thus decreases the infrastructure and setup investments.

h3. Unit test, baby!

You may opt that this still does not give you real continuous integration benefits like fast feedback.

And that's where Drone shines again: you may simply switch from real browser to mocked browser.

That way Arquillian will automatically start up container, Drone will start mocked browser and the tests will be executed without need of any prepared enviroment and faster than in real browsers.

Just note, that you can get really precise results, near to real browser implementation, when you use right mocked browser implementation like PhantomJS, which is near to Chrome implementation.

h2. Let developers and QE get along

What we did prepared as also for paradigm switch: our QE does not ensure all testing of UI, but they are responsible for verifying UI by tests which are already written.

Note that this does not completely eliminate manual testing, it will be always necessary, but at least it minimizes it to appropriate level.

h3. Developers Responsible for Testing

The responsibility for writing initial tests for every new component was laid on developers.

The reason of this is simple: the developer can write test to support his development and get more confidence in the changes he or his colleagues made.

He can run tests before commit and then pass them to continuous integration so the commits will be double-checked and developer will get fast feedback if they don't pass.

h3. QE run tests in real environment and improves them

Without responsibility of writing tests, QE can focus on extending the coverage by porting tests to supported platforms and thus increase confidence in code of the application.

Additionally, then can change and extend tests as necessary, since they are not so hard to read and write using Page Fragments.

h2. Conclusion

As a result, we can now:

* develop test fast
* test what is important
* test with real browsers (optionally: in the cloud)
* test with real container
* run integration tests as they would be unit tests

We have put pretty extensive effort to improve testing, because we believe its fundamental part of success of every open-source project where many people may contribute to.

And what's even better that you can achieve the same success because we are development those tools in open!

h2. Call to Action

Call to all responsible developers and managers: There is no longer any excuse for not testing your code!
